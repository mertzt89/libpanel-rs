// This file was generated by gir (https://github.com/gtk-rs/gir)
// from
// from gir-files (https://github.com/gtk-rs/gir-files.git)
// DO NOT EDIT

use crate::Position;
use glib::{
    prelude::*,
    signal::{connect_raw, SignalHandlerId},
    translate::*,
};
use std::{boxed::Box as Box_, fmt, mem::transmute};

glib::wrapper! {
    #[doc(alias = "PanelSessionItem")]
    pub struct SessionItem(Object<ffi::PanelSessionItem, ffi::PanelSessionItemClass>);

    match fn {
        type_ => || ffi::panel_session_item_get_type(),
    }
}

impl SessionItem {
    #[doc(alias = "panel_session_item_new")]
    pub fn new() -> SessionItem {
        assert_initialized_main_thread!();
        unsafe { from_glib_full(ffi::panel_session_item_new()) }
    }

    // rustdoc-stripper-ignore-next
    /// Creates a new builder-pattern struct instance to construct [`SessionItem`] objects.
    ///
    /// This method returns an instance of [`SessionItemBuilder`](crate::builders::SessionItemBuilder) which can be used to create [`SessionItem`] objects.
    pub fn builder() -> SessionItemBuilder {
        SessionItemBuilder::new()
    }

    #[doc(alias = "panel_session_item_get_id")]
    #[doc(alias = "get_id")]
    pub fn id(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::panel_session_item_get_id(self.to_glib_none().0)) }
    }

    //#[doc(alias = "panel_session_item_get_metadata")]
    //#[doc(alias = "get_metadata")]
    //pub fn is_metadata(&self, key: &str, format: &str, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> bool {
    //    unsafe { TODO: call ffi:panel_session_item_get_metadata() }
    //}

    #[doc(alias = "panel_session_item_get_metadata_value")]
    #[doc(alias = "get_metadata_value")]
    pub fn metadata_value(
        &self,
        key: &str,
        expected_type: Option<&glib::VariantTy>,
    ) -> Option<glib::Variant> {
        unsafe {
            from_glib_full(ffi::panel_session_item_get_metadata_value(
                self.to_glib_none().0,
                key.to_glib_none().0,
                expected_type.to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "panel_session_item_get_module_name")]
    #[doc(alias = "get_module_name")]
    pub fn module_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::panel_session_item_get_module_name(
                self.to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "panel_session_item_get_position")]
    #[doc(alias = "get_position")]
    pub fn position(&self) -> Option<Position> {
        unsafe { from_glib_none(ffi::panel_session_item_get_position(self.to_glib_none().0)) }
    }

    #[doc(alias = "panel_session_item_get_type_hint")]
    #[doc(alias = "get_type_hint")]
    pub fn type_hint(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::panel_session_item_get_type_hint(self.to_glib_none().0)) }
    }

    #[doc(alias = "panel_session_item_get_workspace")]
    #[doc(alias = "get_workspace")]
    pub fn workspace(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::panel_session_item_get_workspace(self.to_glib_none().0)) }
    }

    #[doc(alias = "panel_session_item_has_metadata_with_type")]
    pub fn has_metadata_with_type(&self, key: &str, expected_type: &glib::VariantTy) -> bool {
        unsafe {
            from_glib(ffi::panel_session_item_has_metadata_with_type(
                self.to_glib_none().0,
                key.to_glib_none().0,
                expected_type.to_glib_none().0,
            ))
        }
    }

    #[doc(alias = "panel_session_item_set_id")]
    pub fn set_id(&self, id: Option<&str>) {
        unsafe {
            ffi::panel_session_item_set_id(self.to_glib_none().0, id.to_glib_none().0);
        }
    }

    #[doc(alias = "panel_session_item_set_metadata_value")]
    pub fn set_metadata_value(&self, key: &str, value: Option<&glib::Variant>) {
        unsafe {
            ffi::panel_session_item_set_metadata_value(
                self.to_glib_none().0,
                key.to_glib_none().0,
                value.to_glib_none().0,
            );
        }
    }

    #[doc(alias = "panel_session_item_set_module_name")]
    pub fn set_module_name(&self, module_name: Option<&str>) {
        unsafe {
            ffi::panel_session_item_set_module_name(
                self.to_glib_none().0,
                module_name.to_glib_none().0,
            );
        }
    }

    #[doc(alias = "panel_session_item_set_position")]
    pub fn set_position(&self, position: Option<&Position>) {
        unsafe {
            ffi::panel_session_item_set_position(self.to_glib_none().0, position.to_glib_none().0);
        }
    }

    #[doc(alias = "panel_session_item_set_type_hint")]
    pub fn set_type_hint(&self, type_hint: Option<&str>) {
        unsafe {
            ffi::panel_session_item_set_type_hint(
                self.to_glib_none().0,
                type_hint.to_glib_none().0,
            );
        }
    }

    #[doc(alias = "panel_session_item_set_workspace")]
    pub fn set_workspace(&self, workspace: Option<&str>) {
        unsafe {
            ffi::panel_session_item_set_workspace(
                self.to_glib_none().0,
                workspace.to_glib_none().0,
            );
        }
    }

    #[doc(alias = "id")]
    pub fn connect_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_id_trampoline<F: Fn(&SessionItem) + 'static>(
            this: *mut ffi::PanelSessionItem,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::id\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_id_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "module-name")]
    pub fn connect_module_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_module_name_trampoline<F: Fn(&SessionItem) + 'static>(
            this: *mut ffi::PanelSessionItem,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::module-name\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_module_name_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "position")]
    pub fn connect_position_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_position_trampoline<F: Fn(&SessionItem) + 'static>(
            this: *mut ffi::PanelSessionItem,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::position\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_position_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "type-hint")]
    pub fn connect_type_hint_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_type_hint_trampoline<F: Fn(&SessionItem) + 'static>(
            this: *mut ffi::PanelSessionItem,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::type-hint\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_type_hint_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "workspace")]
    pub fn connect_workspace_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_workspace_trampoline<F: Fn(&SessionItem) + 'static>(
            this: *mut ffi::PanelSessionItem,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"notify::workspace\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    notify_workspace_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl Default for SessionItem {
    fn default() -> Self {
        Self::new()
    }
}

// rustdoc-stripper-ignore-next
/// A [builder-pattern] type to construct [`SessionItem`] objects.
///
/// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct SessionItemBuilder {
    builder: glib::object::ObjectBuilder<'static, SessionItem>,
}

impl SessionItemBuilder {
    fn new() -> Self {
        Self {
            builder: glib::object::Object::builder(),
        }
    }

    pub fn id(self, id: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("id", id.into()),
        }
    }

    pub fn module_name(self, module_name: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("module-name", module_name.into()),
        }
    }

    pub fn position(self, position: &Position) -> Self {
        Self {
            builder: self.builder.property("position", position.clone()),
        }
    }

    pub fn type_hint(self, type_hint: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("type-hint", type_hint.into()),
        }
    }

    pub fn workspace(self, workspace: impl Into<glib::GString>) -> Self {
        Self {
            builder: self.builder.property("workspace", workspace.into()),
        }
    }

    // rustdoc-stripper-ignore-next
    /// Build the [`SessionItem`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> SessionItem {
        self.builder.build()
    }
}

impl fmt::Display for SessionItem {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("SessionItem")
    }
}
